name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1
  # Shared cache key prefix for better cache reuse across jobs
  CACHE_VERSION: v1

jobs:
  format:
    name: Format Check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt

      - name: Check formatting
        run: cargo fmt --all -- --check

  clippy:
    name: Clippy Lints
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy

      - name: Install protobuf compiler
        run: sudo apt-get update && sudo apt-get install -y protobuf-compiler

      - name: Cache cargo
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-${{ env.CACHE_VERSION }}-cargo-clippy-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-${{ env.CACHE_VERSION }}-cargo-clippy-
            ${{ runner.os }}-${{ env.CACHE_VERSION }}-cargo-

      - name: Run clippy
        run: cargo clippy --all-targets --all-features -- -D warnings

  test:
    name: Test Suite
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:17-alpine
        env:
          POSTGRES_USER: everruns
          POSTGRES_PASSWORD: everruns
          POSTGRES_DB: everruns_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    env:
      DATABASE_URL: postgres://everruns:everruns@localhost:5432/everruns_test

    steps:
      - uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Install protobuf compiler
        run: sudo apt-get update && sudo apt-get install -y protobuf-compiler

      - name: Cache cargo
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-${{ env.CACHE_VERSION }}-cargo-test-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-${{ env.CACHE_VERSION }}-cargo-test-
            ${{ runner.os }}-${{ env.CACHE_VERSION }}-cargo-

      - name: Cache sqlx-cli
        uses: actions/cache@v4
        with:
          path: ~/.cargo/bin/sqlx
          key: ${{ runner.os }}-sqlx-cli-0.8

      - name: Install sqlx-cli
        run: |
          if [ ! -f ~/.cargo/bin/sqlx ]; then
            cargo install sqlx-cli --no-default-features --features postgres
          fi

      - name: Run migrations
        run: sqlx migrate run --source crates/control-plane/migrations

      - name: Run tests
        run: cargo test --all-features

  build:
    name: Build Check
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Install protobuf compiler
        run: sudo apt-get update && sudo apt-get install -y protobuf-compiler

      - name: Cache cargo
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-${{ env.CACHE_VERSION }}-cargo-build-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-${{ env.CACHE_VERSION }}-cargo-build-
            ${{ runner.os }}-${{ env.CACHE_VERSION }}-cargo-

      - name: Build
        run: cargo build --all-features --release

  ui-build:
    name: UI Build & Lint
    runs-on: ubuntu-latest

    defaults:
      run:
        working-directory: apps/ui

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: apps/ui/package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Cache Next.js build
        uses: actions/cache@v4
        with:
          path: apps/ui/.next/cache
          # Generate a new cache whenever packages or source files change
          key: ${{ runner.os }}-nextjs-${{ hashFiles('apps/ui/package-lock.json') }}-${{ hashFiles('apps/ui/src/**/*', 'apps/ui/app/**/*') }}
          restore-keys: |
            ${{ runner.os }}-nextjs-${{ hashFiles('apps/ui/package-lock.json') }}-
            ${{ runner.os }}-nextjs-

      - name: Lint
        run: npm run lint

      - name: Type check & build
        run: npm run build

  integration-test:
    name: Integration Tests
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:17-alpine
        env:
          POSTGRES_USER: everruns
          POSTGRES_PASSWORD: everruns
          POSTGRES_DB: everruns
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    env:
      DATABASE_URL: postgres://everruns:everruns@localhost:5432/everruns
      TEMPORAL_ADDRESS: localhost:7233
      GRPC_ADDRESS: 127.0.0.1:9001
      AUTH_MODE: none
      SECRETS_ENCRYPTION_KEY: kek-v1:8B3uCQ4Znx45hl5nB+PKVriRrj/KtEVM+wBZ2VGa9vY=

    steps:
      - uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Install protobuf compiler
        run: sudo apt-get update && sudo apt-get install -y protobuf-compiler

      - name: Start Temporal
        run: |
          # Get the postgres container's network
          POSTGRES_CONTAINER=$(docker ps --filter "ancestor=postgres:17-alpine" -q)
          NETWORK=$(docker inspect $POSTGRES_CONTAINER --format '{{range $key, $value := .NetworkSettings.Networks}}{{$key}}{{end}}')
          echo "Postgres container: $POSTGRES_CONTAINER on network: $NETWORK"

          # Get postgres container IP
          POSTGRES_IP=$(docker inspect $POSTGRES_CONTAINER --format '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}')
          echo "Postgres IP: $POSTGRES_IP"

          # Start Temporal on the same network
          docker run -d --name temporal \
            --network $NETWORK \
            -p 7233:7233 \
            -e DB=postgres12 \
            -e DB_PORT=5432 \
            -e POSTGRES_USER=everruns \
            -e POSTGRES_PWD=everruns \
            -e POSTGRES_SEEDS=$POSTGRES_IP \
            temporalio/auto-setup:latest

          # Wait for Temporal to be ready by checking if it accepts connections
          echo "Waiting for Temporal to start..."
          for i in $(seq 1 90); do
            # Check if Temporal's gRPC port is accepting connections
            if nc -z localhost 7233 2>/dev/null; then
              echo "Temporal port 7233 is accepting connections"
              # Give it a few more seconds to fully initialize
              sleep 5
              echo "Temporal is ready"
              exit 0
            fi
            echo "Waiting... ($i/90)"
            sleep 2
          done
          echo "Temporal failed to start"
          docker logs temporal
          exit 1

      - name: Cache cargo
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-${{ env.CACHE_VERSION }}-cargo-integration-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-${{ env.CACHE_VERSION }}-cargo-integration-
            ${{ runner.os }}-${{ env.CACHE_VERSION }}-cargo-

      - name: Cache sqlx-cli
        uses: actions/cache@v4
        with:
          path: ~/.cargo/bin/sqlx
          key: ${{ runner.os }}-sqlx-cli-0.8

      - name: Install sqlx-cli
        run: |
          if [ ! -f ~/.cargo/bin/sqlx ]; then
            cargo install sqlx-cli --no-default-features --features postgres
          fi

      - name: Run migrations
        run: sqlx migrate run --source crates/control-plane/migrations

      - name: Build API and Worker
        run: |
          cargo build -p everruns-control-plane
          cargo build -p everruns-worker

      - name: Start API server
        run: |
          cargo run -p everruns-control-plane > /tmp/api.log 2>&1 &
          API_PID=$!
          echo "API_PID=$API_PID" >> $GITHUB_ENV
          # Wait for API to be ready
          timeout 30 bash -c 'until curl -s http://localhost:9000/health > /dev/null; do sleep 1; done'
          echo "API is ready"

      - name: Start Worker
        run: |
          cargo run -p everruns-worker > /tmp/worker.log 2>&1 &
          WORKER_PID=$!
          echo "WORKER_PID=$WORKER_PID" >> $GITHUB_ENV
          # Give worker time to connect to Temporal
          sleep 5
          # Verify worker is still running
          if kill -0 $WORKER_PID 2>/dev/null; then
            echo "Worker is running (PID: $WORKER_PID)"
          else
            echo "Worker failed to start"
            cat /tmp/worker.log
            exit 1
          fi

      - name: Run integration tests
        run: |
          # Run ignored integration tests, but exclude tests that require LLM API keys
          cargo test -p everruns-control-plane --test integration_test -- --ignored --test-threads=1 \
            --skip test_message_triggers_agent_workflow

      - name: Show logs on failure
        if: failure()
        run: |
          echo "=== API Logs ==="
          cat /tmp/api.log || true
          echo "=== Worker Logs ==="
          cat /tmp/worker.log || true

      - name: Stop Worker
        if: always()
        run: kill $WORKER_PID || true

      - name: Stop API server
        if: always()
        run: kill $API_PID || true

      - name: Stop Temporal
        if: always()
        run: docker stop temporal || true

  docs-build:
    name: Docs Build & Check
    runs-on: ubuntu-latest

    defaults:
      run:
        working-directory: apps/docs

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: apps/docs/package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Astro check
        run: npm run check

      - name: Build docs
        run: npm run build

  # Docker builds using matrix for parallel execution
  docker-build:
    name: Docker Build (${{ matrix.target }})
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - target: api
            dockerfile: docker/Dockerfile.unified
            image: everruns-control-plane
          - target: worker
            dockerfile: docker/Dockerfile.unified
            image: everruns-worker

    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build ${{ matrix.target }} Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ${{ matrix.dockerfile }}
          target: ${{ matrix.target }}
          push: false
          tags: ${{ matrix.image }}:ci
          # Use shared cache scope for better layer reuse between api and worker
          cache-from: type=gha,scope=docker-${{ matrix.target }}
          cache-to: type=gha,mode=max,scope=docker-${{ matrix.target }}
