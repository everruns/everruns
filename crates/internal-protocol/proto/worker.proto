// Internal protocol for worker <-> control plane communication
// Decision: gRPC for worker communication (industry standard, already in stack via Temporal)
// Decision: Rust types in schemas crate are source of truth, proto mirrors them
// Decision: Batched RPCs for latency optimization (GetTurnContext, EmitEventStream)
// Decision: Use google.protobuf.Value/Struct for JSON values instead of strings

syntax = "proto3";

package everruns.internal;

import "google/protobuf/struct.proto";

// Service for workers to communicate with control plane
service WorkerService {
    // === Batched operations (latency optimized) ===

    // Get all context needed to start a turn (replaces 4 separate calls)
    // Combines: GetAgent + GetSession + LoadMessages + GetModelWithProvider
    rpc GetTurnContext(GetTurnContextRequest) returns (GetTurnContextResponse);

    // Stream events to control plane (efficient bulk emission)
    rpc EmitEventStream(stream EmitEventRequest) returns (EmitEventStreamResponse);

    // === Individual operations (still available) ===

    // Agent operations
    rpc GetAgent(GetAgentRequest) returns (GetAgentResponse);

    // Session operations
    rpc GetSession(GetSessionRequest) returns (GetSessionResponse);
    rpc SetSessionStatus(SetSessionStatusRequest) returns (SetSessionStatusResponse);

    // Message operations
    rpc LoadMessages(LoadMessagesRequest) returns (LoadMessagesResponse);
    rpc AddMessage(AddMessageRequest) returns (AddMessageResponse);

    // Event operations
    rpc EmitEvent(EmitEventRequest) returns (EmitEventResponse);
    rpc CommitExec(CommitExecRequest) returns (CommitExecResponse);

    // LLM Provider operations
    rpc GetModelWithProvider(GetModelWithProviderRequest) returns (GetModelWithProviderResponse);
    rpc GetDefaultModel(GetDefaultModelRequest) returns (GetDefaultModelResponse);

    // Session file operations (virtual filesystem)
    rpc SessionReadFile(SessionReadFileRequest) returns (SessionReadFileResponse);
    rpc SessionWriteFile(SessionWriteFileRequest) returns (SessionWriteFileResponse);
    rpc SessionDeleteFile(SessionDeleteFileRequest) returns (SessionDeleteFileResponse);
    rpc SessionListDirectory(SessionListDirectoryRequest) returns (SessionListDirectoryResponse);
    rpc SessionStatFile(SessionStatFileRequest) returns (SessionStatFileResponse);
    rpc SessionGrepFiles(SessionGrepFilesRequest) returns (SessionGrepFilesResponse);
    rpc SessionCreateDirectory(SessionCreateDirectoryRequest) returns (SessionCreateDirectoryResponse);

    // === Durable execution operations ===
    // These operations allow workers to interact with the durable task queue
    // without direct database access

    // Create a new durable workflow instance
    rpc CreateDurableWorkflow(CreateDurableWorkflowRequest) returns (CreateDurableWorkflowResponse);

    // Get workflow status
    rpc GetDurableWorkflowStatus(GetDurableWorkflowStatusRequest) returns (GetDurableWorkflowStatusResponse);

    // Update workflow status
    rpc UpdateDurableWorkflowStatus(UpdateDurableWorkflowStatusRequest) returns (UpdateDurableWorkflowStatusResponse);

    // Enqueue a task to the durable task queue
    rpc EnqueueDurableTask(EnqueueDurableTaskRequest) returns (EnqueueDurableTaskResponse);

    // Claim tasks from the queue (for worker polling)
    rpc ClaimDurableTasks(ClaimDurableTasksRequest) returns (ClaimDurableTasksResponse);

    // Complete a task successfully
    rpc CompleteDurableTask(CompleteDurableTaskRequest) returns (CompleteDurableTaskResponse);

    // Fail a task
    rpc FailDurableTask(FailDurableTaskRequest) returns (FailDurableTaskResponse);

    // Send heartbeat for a claimed task
    rpc HeartbeatDurableTask(HeartbeatDurableTaskRequest) returns (HeartbeatDurableTaskResponse);

    // Count active (non-terminal) workflows
    rpc CountActiveDurableWorkflows(CountActiveDurableWorkflowsRequest) returns (CountActiveDurableWorkflowsResponse);
}

// ============================================================================
// Common types
// ============================================================================

message Uuid {
    string value = 1;
}

message Timestamp {
    int64 seconds = 1;
    int32 nanos = 2;
}

// ============================================================================
// Batched context request/response
// ============================================================================

message GetTurnContextRequest {
    Uuid session_id = 1;
}

message GetTurnContextResponse {
    Agent agent = 1;
    Session session = 2;
    repeated Message messages = 3;
    ModelWithProvider model = 4;
}

// ============================================================================
// Agent types
// ============================================================================

message Agent {
    Uuid id = 1;
    string name = 2;
    string description = 3;
    string system_prompt = 4;
    optional Uuid default_model_id = 5;
    optional float temperature = 6;
    optional uint32 max_tokens = 7;
    string status = 8;
    Timestamp created_at = 9;
    Timestamp updated_at = 10;
    repeated string capability_ids = 11;
}

message GetAgentRequest {
    Uuid agent_id = 1;
}

message GetAgentResponse {
    optional Agent agent = 1;
}

// ============================================================================
// Session types
// ============================================================================

message Session {
    Uuid id = 1;
    Uuid agent_id = 2;
    string title = 3;
    string status = 4;
    Timestamp created_at = 5;
    Timestamp updated_at = 6;
    optional Uuid default_model_id = 7;
}

message GetSessionRequest {
    Uuid session_id = 1;
}

message GetSessionResponse {
    optional Session session = 1;
}

message SetSessionStatusRequest {
    Uuid session_id = 1;
    string status = 2;  // "started", "active", "idle"
}

message SetSessionStatusResponse {
    Session session = 1;
}

// ============================================================================
// Message types
// ============================================================================

message Message {
    Uuid id = 1;
    string role = 2;
    google.protobuf.ListValue content = 3;  // Vec<ContentPart>
    optional google.protobuf.Struct controls = 4;  // Controls object
    optional google.protobuf.Struct metadata = 5;  // metadata object
    Timestamp created_at = 6;
}

message LoadMessagesRequest {
    Uuid session_id = 1;
}

message LoadMessagesResponse {
    repeated Message messages = 1;
}

message AddMessageRequest {
    Uuid session_id = 1;
    string role = 2;
    google.protobuf.ListValue content = 3;
    optional google.protobuf.Struct controls = 4;
    optional google.protobuf.Struct metadata = 5;
    repeated string tags = 6;
}

message AddMessageResponse {
    Message message = 1;
}

// ============================================================================
// Event types
// ============================================================================

// EventRequest - input type for event ingestion (no id or sequence)
// Data is untyped Struct - deserialized based on event_type field
message EventRequest {
    string event_type = 1;
    Timestamp ts = 2;
    EventContext context = 3;
    google.protobuf.Struct data = 4;  // Event-specific payload (deserialized based on event_type)
    optional google.protobuf.Struct metadata = 5;  // Optional metadata object
    repeated string tags = 6;  // Optional tags
}

// Event - stored event with id and sequence assigned by storage
message Event {
    Uuid id = 1;
    string event_type = 2;
    Timestamp ts = 3;
    EventContext context = 4;
    google.protobuf.Struct data = 5;  // Event-specific payload (deserialized based on event_type)
    optional google.protobuf.Struct metadata = 6;  // Optional metadata object
    repeated string tags = 7;  // Optional tags
    int32 sequence = 8;  // Sequence number within session (always set for stored events)
}

message EventContext {
    Uuid session_id = 1;
    optional Uuid turn_id = 2;
    optional Uuid input_message_id = 3;
    optional Uuid exec_id = 4;  // For idempotency
}

message EmitEventRequest {
    EventRequest event = 1;
}

message EmitEventResponse {
    Event event = 1;  // The stored event with id and sequence
}

message EmitEventStreamResponse {
    int32 events_processed = 1;
}

// Commit an execution ID to prevent duplicate processing on retry
message CommitExecRequest {
    Uuid session_id = 1;
    Uuid exec_id = 2;
}

message CommitExecResponse {
    bool committed = 1;  // true if this was a new commit, false if already committed
}

// ============================================================================
// LLM Provider types
// ============================================================================

message ModelWithProvider {
    string model = 1;
    string provider_type = 2;
    optional string api_key = 3;  // Decrypted by control plane
    optional string base_url = 4;
}

message GetModelWithProviderRequest {
    Uuid model_id = 1;
}

message GetModelWithProviderResponse {
    optional ModelWithProvider model = 1;
}

message GetDefaultModelRequest {}

message GetDefaultModelResponse {
    optional ModelWithProvider model = 1;
}

// ============================================================================
// Session file types (virtual filesystem)
// ============================================================================

message SessionFile {
    Uuid id = 1;
    Uuid session_id = 2;
    string path = 3;
    string name = 4;
    optional string content = 5;
    string encoding = 6;
    bool is_directory = 7;
    bool is_readonly = 8;
    int64 size_bytes = 9;
    Timestamp created_at = 10;
    Timestamp updated_at = 11;
}

message FileInfo {
    Uuid id = 1;
    Uuid session_id = 2;
    string path = 3;
    string name = 4;
    bool is_directory = 5;
    bool is_readonly = 6;
    int64 size_bytes = 7;
    Timestamp created_at = 8;
    Timestamp updated_at = 9;
}

message FileStat {
    string path = 1;
    string name = 2;
    bool is_directory = 3;
    bool is_readonly = 4;
    int64 size_bytes = 5;
    Timestamp created_at = 6;
    Timestamp updated_at = 7;
}

message GrepMatch {
    string path = 1;
    uint64 line_number = 2;
    string line = 3;
}

message SessionReadFileRequest {
    Uuid session_id = 1;
    string path = 2;
}

message SessionReadFileResponse {
    optional SessionFile file = 1;
}

message SessionWriteFileRequest {
    Uuid session_id = 1;
    string path = 2;
    string content = 3;
    string encoding = 4;
}

message SessionWriteFileResponse {
    SessionFile file = 1;
}

message SessionDeleteFileRequest {
    Uuid session_id = 1;
    string path = 2;
    bool recursive = 3;
}

message SessionDeleteFileResponse {
    bool deleted = 1;
}

message SessionListDirectoryRequest {
    Uuid session_id = 1;
    string path = 2;
}

message SessionListDirectoryResponse {
    repeated FileInfo files = 1;
}

message SessionStatFileRequest {
    Uuid session_id = 1;
    string path = 2;
}

message SessionStatFileResponse {
    optional FileStat stat = 1;
}

message SessionGrepFilesRequest {
    Uuid session_id = 1;
    string pattern = 2;
    optional string path_pattern = 3;
}

message SessionGrepFilesResponse {
    repeated GrepMatch matches = 1;
}

message SessionCreateDirectoryRequest {
    Uuid session_id = 1;
    string path = 2;
}

message SessionCreateDirectoryResponse {
    FileInfo directory = 1;
}

// ============================================================================
// Durable execution types
// ============================================================================

// Workflow status enum (mirrors everruns_durable::WorkflowStatus)
enum DurableWorkflowStatus {
    DURABLE_WORKFLOW_STATUS_UNSPECIFIED = 0;
    DURABLE_WORKFLOW_STATUS_PENDING = 1;
    DURABLE_WORKFLOW_STATUS_RUNNING = 2;
    DURABLE_WORKFLOW_STATUS_COMPLETED = 3;
    DURABLE_WORKFLOW_STATUS_FAILED = 4;
    DURABLE_WORKFLOW_STATUS_CANCELLED = 5;
}

// Task status enum
enum DurableTaskStatus {
    DURABLE_TASK_STATUS_UNSPECIFIED = 0;
    DURABLE_TASK_STATUS_PENDING = 1;
    DURABLE_TASK_STATUS_CLAIMED = 2;
    DURABLE_TASK_STATUS_COMPLETED = 3;
    DURABLE_TASK_STATUS_FAILED = 4;
}

// Activity options for task scheduling
message DurableActivityOptions {
    optional int32 max_retries = 1;
    optional int64 retry_delay_ms = 2;
    optional int64 timeout_ms = 3;
}

// Task definition for enqueueing
message DurableTaskDefinition {
    Uuid workflow_id = 1;
    string activity_id = 2;
    string activity_type = 3;
    google.protobuf.Struct input = 4;
    optional DurableActivityOptions options = 5;
}

// Claimed task returned from claim operation
message DurableClaimedTask {
    Uuid id = 1;
    Uuid workflow_id = 2;
    string activity_id = 3;
    string activity_type = 4;
    google.protobuf.Struct input = 5;
    int32 attempt = 6;
}

// === Create workflow ===

message CreateDurableWorkflowRequest {
    string workflow_type = 1;
    google.protobuf.Struct input = 2;
    optional Uuid workflow_id = 3;  // Optional, will generate if not provided
}

message CreateDurableWorkflowResponse {
    Uuid workflow_id = 1;
}

// === Get workflow status ===

message GetDurableWorkflowStatusRequest {
    Uuid workflow_id = 1;
}

message GetDurableWorkflowStatusResponse {
    DurableWorkflowStatus status = 1;
    optional google.protobuf.Struct output = 2;
    optional string error = 3;
}

// === Update workflow status ===

message UpdateDurableWorkflowStatusRequest {
    Uuid workflow_id = 1;
    DurableWorkflowStatus status = 2;
    optional google.protobuf.Struct output = 3;
    optional string error = 4;
}

message UpdateDurableWorkflowStatusResponse {
    bool updated = 1;
}

// === Enqueue task ===

message EnqueueDurableTaskRequest {
    DurableTaskDefinition task = 1;
}

message EnqueueDurableTaskResponse {
    Uuid task_id = 1;
}

// === Claim tasks ===

message ClaimDurableTasksRequest {
    string worker_id = 1;
    repeated string activity_types = 2;
    int32 max_tasks = 3;
}

message ClaimDurableTasksResponse {
    repeated DurableClaimedTask tasks = 1;
}

// === Complete task ===

message CompleteDurableTaskRequest {
    Uuid task_id = 1;
    google.protobuf.Struct output = 2;
}

message CompleteDurableTaskResponse {
    bool completed = 1;
}

// === Fail task ===

message FailDurableTaskRequest {
    Uuid task_id = 1;
    string error = 2;
}

message FailDurableTaskResponse {
    bool failed = 1;
    bool will_retry = 2;
}

// === Heartbeat task ===

message HeartbeatDurableTaskRequest {
    Uuid task_id = 1;
    string worker_id = 2;
    optional google.protobuf.Struct details = 3;  // Optional progress/status details
}

message HeartbeatDurableTaskResponse {
    bool acknowledged = 1;
    bool should_cancel = 2;
}

// === Count active workflows ===

message CountActiveDurableWorkflowsRequest {}

message CountActiveDurableWorkflowsResponse {
    int64 count = 1;
}
