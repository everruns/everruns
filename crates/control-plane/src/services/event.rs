// Event service for business logic
//
// Events are SSE notifications following the standard event protocol.
// Events are stored in the events table and streamed to clients via SSE.
// This service is the central entry point for event ingestion from both
// HTTP API and gRPC service.
//
// IMPORTANT: Event IDs are ALWAYS generated by the database (uuidv7()).
// EventRow columns map directly to Event fields - no JSON wrapping needed.
//
// Event Listeners:
// After persisting events, the service notifies registered listeners for
// observability integrations (OTel spans, metrics, etc.). Listeners are
// called synchronously but should be non-blocking.

use crate::storage::{models::CreateEventRow, EventRow, StorageBackend};
use anyhow::Result;
use everruns_core::{Event, EventData, EventListener, EventRequest};
use std::sync::Arc;
use uuid::Uuid;

#[derive(Clone)]
pub struct EventService {
    db: Arc<StorageBackend>,
    /// Registered event listeners for observability
    listeners: Arc<Vec<Arc<dyn EventListener>>>,
}

impl EventService {
    pub fn new(db: Arc<StorageBackend>) -> Self {
        Self {
            db,
            listeners: Arc::new(Vec::new()),
        }
    }

    /// Create an EventService with registered listeners
    pub fn with_listeners(db: Arc<StorageBackend>, listeners: Vec<Arc<dyn EventListener>>) -> Self {
        Self {
            db,
            listeners: Arc::new(listeners),
        }
    }

    /// Notify all registered listeners about an event
    async fn notify_listeners(&self, event: &Event) {
        for listener in self.listeners.iter() {
            // Check if listener wants this event type
            let should_notify = listener
                .event_types()
                .map(|types| types.contains(&event.event_type.as_str()))
                .unwrap_or(true); // None means all events

            if should_notify {
                listener.on_event(event).await;
            }
        }
    }

    /// Emit a typed event request and store it in the database.
    /// Returns the stored event with its database-assigned id and sequence number.
    ///
    /// This is the primary method for event ingestion, used by both
    /// HTTP API and gRPC service.
    ///
    /// After storing, all registered listeners are notified.
    ///
    /// Note: The event ID is generated by the database, not by Rust.
    pub async fn emit(&self, request: EventRequest) -> Result<Event> {
        let create_row = CreateEventRow {
            session_id: request.session_id,
            event_type: request.event_type,
            ts: request.ts,
            context: serde_json::to_value(&request.context)?,
            data: serde_json::to_value(&request.data)?,
            metadata: request.metadata,
            tags: request.tags,
        };

        let row = self.db.create_event(create_row).await?;
        let event = Self::row_to_event(row);

        // Notify listeners after persisting
        self.notify_listeners(&event).await;

        Ok(event)
    }

    /// Emit a batch of typed event requests and store them in the database.
    /// Returns the count of successfully stored events.
    ///
    /// This method is optimized for bulk event ingestion from workers.
    /// All registered listeners are notified for each event.
    pub async fn emit_batch(&self, requests: Vec<EventRequest>) -> Result<i32> {
        let mut count = 0i32;

        for request in requests {
            let create_row = CreateEventRow {
                session_id: request.session_id,
                event_type: request.event_type,
                ts: request.ts,
                context: serde_json::to_value(&request.context)?,
                data: serde_json::to_value(&request.data)?,
                metadata: request.metadata,
                tags: request.tags,
            };

            let row = self.db.create_event(create_row).await?;
            let event = Self::row_to_event(row);

            // Notify listeners after persisting each event
            self.notify_listeners(&event).await;

            count += 1;
        }

        Ok(count)
    }

    /// Create an event from raw row data
    pub async fn create(&self, input: CreateEventRow) -> Result<Event> {
        let row = self.db.create_event(input).await?;
        let event = Self::row_to_event(row);

        // Notify listeners after persisting
        self.notify_listeners(&event).await;

        Ok(event)
    }

    pub async fn list(
        &self,
        session_id: Uuid,
        since_sequence: Option<i32>,
        since_id: Option<Uuid>,
    ) -> Result<Vec<Event>> {
        let rows = self
            .db
            .list_events(session_id, since_sequence, since_id)
            .await?;
        Ok(rows.into_iter().map(Self::row_to_event).collect())
    }

    /// List events that represent messages (user, agent, tool results)
    /// Used by gRPC service to load conversation history for workers.
    pub async fn list_message_events(&self, session_id: Uuid) -> Result<Vec<Event>> {
        let rows = self.db.list_message_events(session_id).await?;
        Ok(rows.into_iter().map(Self::row_to_event).collect())
    }

    fn row_to_event(row: EventRow) -> Event {
        // Direct mapping from row columns to Event fields
        let data =
            serde_json::from_value(row.data.clone()).unwrap_or_else(|_| EventData::raw(row.data));
        Event {
            id: row.id,
            event_type: row.event_type,
            ts: row.ts,
            session_id: row.session_id,
            context: serde_json::from_value(row.context).unwrap_or_default(),
            data,
            metadata: row.metadata,
            tags: row.tags,
            sequence: Some(row.sequence),
        }
    }
}
